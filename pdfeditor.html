<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cyber PDF Editor</title>
    <link rel="icon" href="icons/icon.png" />
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/signature_pad/dist/signature_pad.umd.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      /* ================= CYBER NEON STYLES ================= */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Orbitron", sans-serif;
      }
      body,
      html {
        width: 100%;
        height: 100%;
        background: #0a0a0a;
        overflow: hidden;
        color: #0ff;
      }
      #app {
        display: grid;
        grid-template-columns: 220px 1fr 260px;
        height: 100vh;
        transition: all 0.3s ease;
      }

      /* Panels */
      #pagesPanel,
      #propertiesPanel {
        background: #111;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        border: 1px solid #0ff;
      }
      #propertiesPanel {
        border-left: 1px solid #0ff;
      }
      .panel-title {
        padding: 12px;
        font-weight: bold;
        background: #111;
        border-bottom: 1px solid #0ff;
        color: #0ff;
      }

      /* Editor */
      #editor {
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Toolbar */
      #toolbar {
        display: flex;
        align-items: center;
        padding: 6px;
        background: #111;
        border-bottom: 1px solid #0ff;
        gap: 5px;
        flex-wrap: wrap;
      }
      .tool-btn {
        padding: 8px 12px;
        background: #222;
        color: #0ff;
        border: 2px solid #0ff;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
      }
      .tool-btn:hover {
        background: #0ff;
        color: #111;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        transform: scale(1.05);
      }
      .tool-btn.active {
        background: #0ff;
        color: #111;
        box-shadow: 0 0 20px rgba(0, 255, 255, 1);
      }
      #zoomIn,
      #zoomOut,
      #exportPDF,
      button[onclick*="loadPDF"] {
        padding: 8px 12px;
        background: #222;
        color: #0ff;
        border: 2px solid #0ff;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
      }
      #zoomIn:hover,
      #zoomOut:hover,
      #exportPDF:hover,
      button[onclick*="loadPDF"]:hover {
        background: #0ff;
        color: #111;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        transform: scale(1.05);
      }
      .toolbar-separator {
        width: 1px;
        height: 25px;
        background: #0ff;
        margin: 0 6px;
      }

      /* Sub Toolbar */
      #subToolbar {
        background: #111;
        border-bottom: 1px solid #0ff;
        padding: 6px;
        min-height: 45px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      /* Pages container */
      #pageContainer {
        flex: 1;
        overflow: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 25px;
        justify-content: flex-start;
        align-items: center;
      }

      .pageCanvasWrapper {
        position: relative;
      }
      .pdfCanvas {
        background: #222;
        box-shadow: 0 0 10px #0ff;
        border-radius: 5px;
      }
      .drawCanvas {
        position: absolute;
        top: 0;
        left: 0;
        cursor: crosshair;
      }
      .drawCanvas.text-tool {
        cursor: text;
      }

      /* Thumbnails */
      #pagesList {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .thumbnail {
        width: 100%;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 3px;
      }
      .thumbnail.selected {
        border-color: #0ff;
      }

      /* Properties Panel */
      #propertiesContent {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      #propertiesContent input,
      #propertiesContent select {
        padding: 4px;
        border-radius: 3px;
        border: none;
        background: #222;
        color: #0ff;
      }

      /* Responsive */
      @media (max-width: 800px) {
        #app {
          grid-template-columns: 130px 1fr 180px;
        }
        .tool-btn {
          padding: 6px 8px;
          font-size: 14px;
        }
      }
      @media (max-width: 600px) {
        #app {
          grid-template-columns: 80px 1fr 120px;
        }
        #pagesPanel,
        #propertiesPanel {
          display: none;
        }
        #app {
          grid-template-columns: 1fr;
        }
        .tool-btn {
          padding: 5px 6px;
          font-size: 12px;
        }
        #toolbar {
          padding: 4px;
          gap: 3px;
        }
        #zoomLabel {
          font-size: 12px;
        }
      }
      @media (max-width: 350px) {
        .tool-btn {
          padding: 4px 5px;
          font-size: 11px;
        }
        #toolbar {
          padding: 3px;
          gap: 2px;
        }
        .toolbar-separator {
          margin: 0 3px;
          height: 20px;
        }
      }
      @media (max-width: 250px) {
        .tool-btn {
          padding: 3px 4px;
          font-size: 10px;
        }
        #toolbar {
          padding: 2px;
          gap: 1px;
        }
        #subToolbar {
          padding: 3px;
          min-height: 35px;
          font-size: 11px;
        }
        #subToolbar label {
          font-size: 10px;
          display: block;
        }
        #subToolbar input,
        #subToolbar select {
          max-width: 60px;
          font-size: 10px;
        }
      }
      @media (max-width: 150px) {
        #app {
          grid-template-columns: 1fr;
        }
        #toolbar {
          overflow-x: auto;
          padding: 1px;
          gap: 0;
        }
        .tool-btn {
          padding: 2px 3px;
          font-size: 9px;
          min-width: 30px;
        }
        .toolbar-separator {
          display: none;
        }
        #zoomLabel {
          display: none;
        }
        #zoomIn,
        #zoomOut {
          padding: 2px 3px;
          font-size: 8px;
        }
        #subToolbar {
          padding: 2px;
          min-height: 25px;
          max-height: 40px;
          overflow-y: auto;
          font-size: 9px;
        }
        #subToolbar label {
          font-size: 8px;
          margin: 1px 0;
        }
        #subToolbar input,
        #subToolbar select {
          padding: 1px 2px;
          font-size: 8px;
          max-width: 50px;
        }
        #pageContainer {
          padding: 5px;
          gap: 10px;
        }
        .pdfCanvas {
          max-width: 100%;
          height: auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- Left Pages Panel -->
      <aside id="pagesPanel">
        <div class="panel-title">Pages</div>
        <div id="pagesList"></div>
      </aside>

      <!-- Editor -->
      <main id="editor">
        <header id="toolbar">
          <button class="tool-btn" data-tool="select" title="Select Tool">
            üëÜ
          </button>
          <button class="tool-btn" data-tool="text" title="Text Tool">
            üìù
          </button>
          <button class="tool-btn" data-tool="pen" title="Pen Tool">‚úèÔ∏è</button>
          <button class="tool-btn" data-tool="highlight" title="Highlight Tool">
            üîÜ
          </button>
          <button class="tool-btn" data-tool="shape" title="Shape Tool">
            ‚¨ú
          </button>
          <button class="tool-btn" data-tool="signature" title="Signature">
            ‚úçÔ∏è
          </button>
          <button class="tool-btn" data-tool="eraser" title="Eraser">üóëÔ∏è</button>
          <div class="toolbar-separator"></div>
          <button id="zoomOut" title="Zoom Out">üîç‚àí</button>
          <span id="zoomLabel">100%</span>
          <button id="zoomIn" title="Zoom In">üîç+</button>
          <div class="toolbar-separator"></div>
          <input type="file" id="loadPDF" accept="application/pdf" hidden />
          <button
            onclick="document.getElementById('loadPDF').click()"
            title="Load PDF"
          >
            üìÇ Load
          </button>
          <button id="exportPDF" title="Export PDF">üíæ Export</button>
        </header>
        <div id="subToolbar"></div>
        <div id="pageContainer"></div>
      </main>

      <!-- Right Properties Panel -->
      <aside id="propertiesPanel">
        <div class="panel-title">Properties</div>
        <div id="propertiesContent">Select an object</div>
      </aside>
    </div>

    <script>
      const pdfjsLib = window["pdfjs-dist/build/pdf"];
      let pdfDoc = null,
        scale = 1.0,
        pages = [],
        currentPage = 1;
      const pageContainer = document.getElementById("pageContainer");
      const pagesList = document.getElementById("pagesList");
      const zoomInBtn = document.getElementById("zoomIn");
      const zoomOutBtn = document.getElementById("zoomOut");
      const zoomLabel = document.getElementById("zoomLabel");
      let tool = "select",
        objects = [],
        objectId = 1,
        selectedObject = null;
      let isDrawing = false,
        tempPath = [],
        isDragging = false,
        dragOffset = { x: 0, y: 0 };
      let undoStack = [],
        redoStack = [];
      let signaturePad = null;

      // ===================== LOAD PDF =====================
      document
        .getElementById("loadPDF")
        .addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const arrayBuffer = await file.arrayBuffer();
          const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
          pdfDoc = await loadingTask.promise;
          await renderAllPages();
        });

      function clearPages() {
        pageContainer.innerHTML = "";
        pagesList.innerHTML = "";
        pages = [];
      }

      async function renderAllPages() {
        clearPages();
        const containerWidth = pageContainer.clientWidth - 40; // 20px padding each side
        for (let i = 1; i <= pdfDoc.numPages; i++) {
          const page = await pdfDoc.getPage(i);
          const viewport = page.getViewport({ scale: 1 }); // base scale
          // Scale to fit width
          const scaleFit = containerWidth / viewport.width;
          const scaledViewport = page.getViewport({ scale: scaleFit });

          const wrapper = document.createElement("div");
          wrapper.className = "pageCanvasWrapper";

          const pdfCanvas = document.createElement("canvas");
          pdfCanvas.className = "pdfCanvas";
          pdfCanvas.width = scaledViewport.width;
          pdfCanvas.height = scaledViewport.height;
          wrapper.appendChild(pdfCanvas);

          const drawCanvas = document.createElement("canvas");
          drawCanvas.className = "drawCanvas";
          drawCanvas.width = scaledViewport.width;
          drawCanvas.height = scaledViewport.height;
          wrapper.appendChild(drawCanvas);

          pageContainer.appendChild(wrapper);

          // Render PDF page
          await page.render({
            canvasContext: pdfCanvas.getContext("2d"),
            viewport: scaledViewport,
          }).promise;

          // Thumbnail (optional)
          const thumb = document.createElement("canvas");
          thumb.className = "thumbnail";
          const thumbCtx = thumb.getContext("2d");
          thumb.width = 200;
          thumb.height = (viewport.height / viewport.width) * 200;
          pagesList.appendChild(thumb);
          await page.render({
            canvasContext: thumbCtx,
            viewport: page.getViewport({ scale: 200 / viewport.width }),
          }).promise;

          // Thumbnail click scroll
          thumb.onclick = () => {
            wrapper.scrollIntoView({ behavior: "smooth" });
            document
              .querySelectorAll(".thumbnail")
              .forEach((t) => t.classList.remove("selected"));
            thumb.classList.add("selected");
          };

          pages.push({ pdfCanvas, drawCanvas, wrapper, scale: scaleFit }); // save scale
        }
        attachCanvasEvents();
      }

      // ===================== ZOOM =====================
      zoomInBtn.onclick = () => {
        scale += 0.1;
        zoomLabel.textContent = Math.round(scale * 100) + "%";
        if (pdfDoc) renderAllPages();
      };
      zoomOutBtn.onclick = () => {
        scale = Math.max(0.1, scale - 0.1);
        zoomLabel.textContent = Math.round(scale * 100) + "%";
        if (pdfDoc) renderAllPages();
      };

      // ===================== TOOLS =====================
      document.querySelectorAll(".tool-btn").forEach((btn) => {
        btn.onclick = () => {
          const isActive = btn.classList.contains("active");
          document
            .querySelectorAll(".tool-btn")
            .forEach((b) => b.classList.remove("active"));

          if (!isActive) {
            btn.classList.add("active");
            tool = btn.dataset.tool;
          } else {
            tool = "select"; // fallback tool when none active
          }

          selectedObject = null;
          updatePropertiesPanel();
          updateSubToolbar();
        };
      });

      function updateSubToolbar() {
        const bar = document.getElementById("subToolbar");
        bar.innerHTML = "";
        if (tool === "text") {
          bar.innerHTML = `
    <label>Font:<select id="fontFamily">
      <option>Arial</option>
      <option>Verdana</option>
      <option>Courier New</option>
      <option>Times New Roman</option>
      <option>Georgia</option>
      <option>Trebuchet MS</option>
      <option>Comic Sans MS</option>
      <option>Impact</option>
      <option>Palatino</option>
      <option>Garamond</option>
      <option>Bookman</option>
      <option>Lucida Console</option>
      <option>Tahoma</option>
      <option>Lucida Grande</option>
      <option>Constanza</option>
      <option>Segoe UI</option>
      <option>Helvetica</option>
      <option>Monaco</option>
      <option>Courier</option>
      <option>Consolas</option>
      <option>Liberation Mono</option>
      <option>DejaVu Sans Mono</option>
      <option>Inconsolata</option>
      <option>Source Code Pro</option>
      <option>Ubuntu Mono</option>
      <option>Roboto</option>
      <option>Open Sans</option>
      <option>Lato</option>
      <option>Raleway</option>
      <option>Playfair Display</option>
      <option>Montserrat</option>
      <option>Poppins</option>
      <option>Nunito</option>
      <option>Merriweather</option>
    </select></label>
    <label>Size:<input type="number" id="fontSize" value="20" min="6" max="200" style="width:60px"></label>
    <label>Color:<input type="color" id="fontColor" value="#0ff"></label>`;
        } else if (tool === "pen" || tool === "highlight") {
          bar.innerHTML = `
    <label>Color:<input type="color" id="penColor" value="${
      tool === "pen" ? "#0ff" : "#0ff"
    }"></label>
    <label>Size:<input type="number" id="penSize" value="${
      tool === "pen" ? 2 : 10
    }" min="1" max="50" style="width:60px"></label>`;
        } else if (tool === "shape") {
          bar.innerHTML = `
    <label>Shape:<select id="shapeType"><option value="rect">Rectangle</option><option value="ellipse">Ellipse</option><option value="line">Line</option><option value="arrow">Arrow</option></select></label>
    <label>Color:<input type="color" id="shapeColor" value="#0ff"></label>
    <label>Thickness:<input type="number" id="shapeSize" value="2" min="1" max="50" style="width:60px"></label>
    <label>Fill:<input type="color" id="shapeFill" value="#0ff" style="opacity:0.3"></label>`;
        }
      }
      updateSubToolbar();

      function saveState() {
        undoStack.push(JSON.stringify(objects));
        if (undoStack.length > 50) undoStack.shift();
        redoStack.length = 0;
      }
      function undo() {
        if (!undoStack.length) return;
        redoStack.push(JSON.stringify(objects));
        objects = JSON.parse(undoStack.pop());
        drawObjects();
      }
      function redo() {
        if (!redoStack.length) return;
        undoStack.push(JSON.stringify(objects));
        objects = JSON.parse(redoStack.pop());
        drawObjects();
      }
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "z") undo();
        if (e.ctrlKey && e.key === "y") redo();
      });

      // ===================== DRAWING =====================
      function getMousePos(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function attachCanvasEvents() {
        pages.forEach((pg, pageIndex) => {
          const canvas = pg.drawCanvas;
          canvas.onmousedown = (e) => {
            if (tool === "select") {
              selectObject(e, pageIndex);
              if (selectedObject) {
                isDragging = true;
                const pos = getMousePos(e, canvas);
                dragOffset.x =
                  pos.x - (selectedObject.x || selectedObject.x1 || 0);
                dragOffset.y =
                  pos.y - (selectedObject.y || selectedObject.y1 || 0);
              }
            } else startTool(e, pageIndex);
          };
          canvas.onmousemove = (e) => {
            if (tool === "select" && isDragging && selectedObject) {
              const pos = getMousePos(e, canvas);
              setObjectX(selectedObject, pos.x - dragOffset.x);
              setObjectY(selectedObject, pos.y - dragOffset.y);
              drawObjects();
            } else moveTool(e, pageIndex);
          };
          canvas.onmouseup = (e) => {
            isDragging = false;
            endTool(e, pageIndex);
          };
          canvas.ondblclick = (e) => {
            selectObject(e, pageIndex);
            if (selectedObject && selectedObject.type === "text") {
              editTextObject(selectedObject, pageIndex);
            }
          };
        });
      }

      function editTextObject(textObj, pageIndex) {
        showTextEditor(textObj, pageIndex);
      }

      function showTextEditor(textObj, pageIndex) {
        const wrapper = pages[pageIndex].wrapper;
        const textarea = document.createElement("textarea");
        textarea.value = textObj.text;

        const font = textObj.font || "Arial";
        const size = textObj.size || 20;
        const color = textObj.color || "#0ff";

        Object.assign(textarea.style, {
          position: "absolute",
          left: textObj.x + "px",
          top: textObj.y - size + "px",
          padding: "4px",
          font: `${size}px ${font}`,
          color: color,
          backgroundColor: "rgba(0, 0, 0, 0.3)",
          border: "2px solid #0ff",
          borderRadius: "4px",
          minWidth: "100px",
          minHeight: size + 8 + "px",
          maxWidth: "500px",
          resize: "both",
          fontFamily: font,
          zIndex: "1000",
          overflow: "hidden",
          lineHeight: "1.2",
          outline: "none",
          boxShadow: "0 0 10px rgba(0, 255, 255, 0.5)",
        });

        textarea.onblur = () => {
          if (textarea.parentNode) {
            textObj.text = textarea.value || textObj.text;
            wrapper.removeChild(textarea);
            drawObjects();
            saveState();
          }
        };

        textarea.onkeydown = (e) => {
          if (e.key === "Escape") {
            if (textarea.parentNode) {
              wrapper.removeChild(textarea);
            }
          }
          // Allow Enter to create newlines (default behavior in textarea)
        };

        textarea.oninput = () => {
          textarea.style.height = "auto";
          textarea.style.height =
            Math.max(size + 8, textarea.scrollHeight) + "px";
          textarea.style.width = "auto";
          textarea.style.width = Math.max(100, textarea.scrollWidth) + "px";
        };

        wrapper.appendChild(textarea);
        setTimeout(() => {
          textarea.focus();
          textarea.select();
        }, 10);
      }

      // ===================== TOOL LOGIC =====================
      function startTool(e, pageIndex) {
        const canvas = pages[pageIndex].drawCanvas;
        const pos = getMousePos(e, canvas);
        if (tool === "pen" || tool === "highlight") {
          isDrawing = true;
          tempPath = [{ x: pos.x, y: pos.y }];
        }
        if (tool === "shape") {
          isDrawing = true;
          tempPath = [
            { x: pos.x, y: pos.y },
            { x: pos.x, y: pos.y },
          ];
        }
        if (tool === "text") {
          const textObj = {
            id: objectId++,
            type: "text",
            page: pageIndex,
            x: pos.x,
            y: pos.y,
            font: document.getElementById("fontFamily").value,
            size: parseInt(document.getElementById("fontSize").value),
            color: document.getElementById("fontColor").value,
            text: "",
          };
          objects.push(textObj);
          selectedObject = textObj;
          showTextEditor(textObj, pageIndex);
        }
        if (tool === "signature") {
          isDrawing = true;
          if (!signaturePad) signaturePad = new SignaturePad(canvas);
          signaturePad.clear();
        }
        if (tool === "eraser") {
          eraseAtPoint(pos, pageIndex);
        }
      }

      function moveTool(e, pageIndex) {
        if (!isDrawing) return;
        const canvas = pages[pageIndex].drawCanvas;
        const pos = getMousePos(e, canvas);
        if (tool === "pen" || tool === "highlight") {
          tempPath.push({ x: pos.x, y: pos.y });
          drawTemp(pageIndex);
        }
        if (tool === "shape") {
          tempPath[1] = { x: pos.x, y: pos.y };
          drawTemp(pageIndex);
        }
        if (tool === "eraser") {
          eraseAtPoint(pos, pageIndex);
        }
      }

      function endTool(e, pageIndex) {
        if (!isDrawing) return;
        isDrawing = false;
        if (tool === "pen") {
          objects.push({
            id: objectId++,
            type: "pen",
            page: pageIndex,
            color: document.getElementById("penColor").value,
            size: parseInt(document.getElementById("penSize").value),
            path: [...tempPath],
          });
          saveState();
        }
        if (tool === "highlight") {
          objects.push({
            id: objectId++,
            type: "highlight",
            page: pageIndex,
            color: document.getElementById("penColor").value,
            size: parseInt(document.getElementById("penSize").value),
            opacity: 0.35,
            path: [...tempPath],
          });
          saveState();
        }
        if (tool === "shape") {
          const st = document.getElementById("shapeType").value;
          const color = document.getElementById("shapeColor").value;
          const size = parseInt(document.getElementById("shapeSize").value);
          const fill = document.getElementById("shapeFill").value;
          objects.push({
            id: objectId++,
            type: st,
            page: pageIndex,
            color,
            size,
            fill,
            x1: tempPath[0].x,
            y1: tempPath[0].y,
            x2: tempPath[1].x,
            y2: tempPath[1].y,
          });
          saveState();
        }
        if (tool === "signature") {
          const data = signaturePad.toData();
          objects.push({
            id: objectId++,
            type: "signature",
            page: pageIndex,
            path: data,
          });
          saveState();
          signaturePad.clear();
        }
        tempPath = [];
      }

      // ===================== DRAWING FUNCTIONS =====================
      function drawObjects() {
        pages.forEach((pg, pageIndex) => {
          const ctx = pg.drawCanvas.getContext("2d");
          ctx.clearRect(0, 0, pg.drawCanvas.width, pg.drawCanvas.height);
          objects
            .filter((o) => o.page === pageIndex)
            .forEach((o) => {
              if (o.type === "pen") drawPen(o, ctx);
              if (o.type === "highlight") drawHighlight(o, ctx);
              if (o.type === "text") drawText(o, ctx);
              if (["rect", "ellipse", "line", "arrow"].includes(o.type))
                drawShape(o, ctx);
              if (o.type === "signature") drawSignature(o, ctx);
            });
        });
      }

      function drawPen(o, ctx) {
        ctx.strokeStyle = o.color;
        ctx.lineWidth = o.size;
        ctx.lineCap = "round";
        ctx.beginPath();
        o.path.forEach((p, i) =>
          i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)
        );
        ctx.stroke();
      }
      function drawHighlight(o, ctx) {
        ctx.strokeStyle = o.color;
        ctx.lineWidth = o.size;
        ctx.globalAlpha = o.opacity || 0.35;
        ctx.beginPath();
        o.path.forEach((p, i) =>
          i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)
        );
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
      function drawText(o, ctx) {
        ctx.fillStyle = o.color;
        ctx.font = `${o.size}px ${o.font}`;
        const lines = o.text.split("\n");
        const lineHeight = o.size * 1.2;
        lines.forEach((line, i) => {
          ctx.fillText(line, o.x, o.y + i * lineHeight);
        });
      }
      function drawShape(o, ctx) {
        ctx.strokeStyle = o.color;
        ctx.lineWidth = o.size;
        const x1 = o.x1,
          y1 = o.y1,
          x2 = o.x2,
          y2 = o.y2;
        if (o.type === "rect") {
          ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
          ctx.fillStyle = o.fill;
          ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
        if (o.type === "ellipse") {
          ctx.beginPath();
          ctx.ellipse(
            (x1 + x2) / 2,
            (y1 + y2) / 2,
            Math.abs(x2 - x1) / 2,
            Math.abs(y2 - y1) / 2,
            0,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = o.fill;
          ctx.fill();
          ctx.stroke();
        }
        if (o.type === "line") {
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        if (o.type === "arrow") {
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
      function drawSignature(o, ctx) {
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        o.path.forEach((stroke) => {
          if (!stroke.points) return;
          stroke.points.forEach((p, i) =>
            i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)
          );
        });
        ctx.stroke();
      }

      function drawTemp(pageIndex) {
        const ctx = pages[pageIndex].drawCanvas.getContext("2d");
        ctx.clearRect(
          0,
          0,
          pages[pageIndex].drawCanvas.width,
          pages[pageIndex].drawCanvas.height
        );
        drawObjects();
        if (tool === "pen" || tool === "highlight") {
          ctx.beginPath();
          ctx.strokeStyle =
            document.getElementById("penColor")?.value || "#0ff";
          ctx.lineWidth = parseInt(
            document.getElementById("penSize")?.value || 2
          );
          ctx.lineCap = "round";
          tempPath.forEach((p, i) =>
            i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)
          );
          ctx.stroke();
        }
        if (tool === "shape") {
          const st = document.getElementById("shapeType")?.value || "rect";
          const color = document.getElementById("shapeColor")?.value || "#0ff";
          const size = parseInt(
            document.getElementById("shapeSize")?.value || 2
          );
          const fill = document.getElementById("shapeFill")?.value || "#0ff";
          const x1 = tempPath[0].x,
            y1 = tempPath[0].y,
            x2 = tempPath[1].x,
            y2 = tempPath[1].y;
          ctx.strokeStyle = color;
          ctx.lineWidth = size;
          if (st === "rect") {
            ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            ctx.fillStyle = fill;
            ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
          }
          if (st === "ellipse") {
            ctx.beginPath();
            ctx.ellipse(
              (x1 + x2) / 2,
              (y1 + y2) / 2,
              Math.abs(x2 - x1) / 2,
              Math.abs(y2 - y1) / 2,
              0,
              0,
              Math.PI * 2
            );
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.stroke();
          }
          if (st === "line") {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          if (st === "arrow") {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
        }
      }

      // ===================== SELECT & PROPERTIES =====================
      function selectObject(e, pageIndex) {
        const pos = getMousePos(e, pages[pageIndex].drawCanvas);
        selectedObject = objects.find(
          (o) => o.page === pageIndex && isPointInsideObject(pos, o)
        );
        updatePropertiesPanel();
      }

      function isPointInsideObject(pos, o) {
        if (o.type === "text") {
          const lines = o.text.split("\n");
          const lineHeight = o.size * 1.2;
          const maxWidth =
            Math.max(...lines.map((l) => l.length)) * o.size * 0.6;
          const totalHeight = lines.length * lineHeight;
          return (
            pos.x >= o.x &&
            pos.x <= o.x + maxWidth &&
            pos.y >= o.y - o.size &&
            pos.y <= o.y + totalHeight
          );
        }
        if (
          ["rect", "ellipse", "line", "arrow", "pen", "highlight"].includes(
            o.type
          )
        ) {
          const x1 = o.x1 || o.x,
            y1 = o.y1 || o.y,
            x2 = o.x2 || x1,
            y2 = o.y2 || y1;
          return (
            pos.x >= Math.min(x1, x2) &&
            pos.x <= Math.max(x1, x2) &&
            pos.y >= Math.min(y1, y2) &&
            pos.y <= Math.max(y1, y2)
          );
        }
        return false;
      }

      function updatePropertiesPanel() {
        const panel = document.getElementById("propertiesContent");
        panel.innerHTML = `
    <h3>Tools Properties</h3>

    <fieldset>
      <legend>Text Tool</legend>
      <label>Font:
        <select id="propFont">
          <option>Arial</option>
          <option>Verdana</option>
          <option>Courier New</option>
          <option>Times New Roman</option>
          <option>Georgia</option>
          <option>Trebuchet MS</option>
          <option>Comic Sans MS</option>
          <option>Impact</option>
          <option>Palatino</option>
          <option>Garamond</option>
          <option>Bookman</option>
          <option>Lucida Console</option>
          <option>Tahoma</option>
          <option>Lucida Grande</option>
          <option>Constanza</option>
          <option>Segoe UI</option>
          <option>Helvetica</option>
          <option>Monaco</option>
          <option>Courier</option>
          <option>Consolas</option>
          <option>Liberation Mono</option>
          <option>DejaVu Sans Mono</option>
          <option>Inconsolata</option>
          <option>Source Code Pro</option>
          <option>Ubuntu Mono</option>
          <option>Roboto</option>
          <option>Open Sans</option>
          <option>Lato</option>
          <option>Raleway</option>
          <option>Playfair Display</option>
          <option>Montserrat</option>
          <option>Poppins</option>
          <option>Nunito</option>
          <option>Merriweather</option>
        </select>
      </label>
      <label>Size:<input type="number" id="propTextSize" value="20" min="6" max="200"></label>
      <label>Color:<input type="color" id="propTextColor" value="#0ff"></label>
    </fieldset>

    <fieldset>
      <legend>Pen Tool</legend>
      <label>Color:<input type="color" id="propPenColor" value="#0ff"></label>
      <label>Size:<input type="number" id="propPenSize" value="2" min="1" max="50"></label>
    </fieldset>

    <fieldset>
      <legend>Highlight Tool</legend>
      <label>Color:<input type="color" id="propHighlightColor" value="#0ff"></label>
      <label>Size:<input type="number" id="propHighlightSize" value="10" min="1" max="50"></label>
    </fieldset>

    <fieldset>
      <legend>Shape Tool</legend>
      <label>Shape:
        <select id="propShapeType">
          <option value="rect">Rectangle</option>
          <option value="ellipse">Ellipse</option>
          <option value="line">Line</option>
          <option value="arrow">Arrow</option>
        </select>
      </label>
      <label>Color:<input type="color" id="propShapeColor" value="#0ff"></label>
      <label>Thickness:<input type="number" id="propShapeSize" value="2" min="1" max="50"></label>
      <label>Fill:<input type="color" id="propShapeFill" value="#0ff" style="opacity:0.3"></label>
    </fieldset>

    <fieldset>
      <legend>Signature Tool</legend>
      <label>Stroke Color:<input type="color" id="propSignatureColor" value="#0ff"></label>
      <label>Stroke Width:<input type="number" id="propSignatureWidth" value="2" min="1" max="10"></label>
    </fieldset>

    <fieldset>
      <legend>Eraser Tool</legend>
      <label>Size:<input type="number" id="propEraserSize" value="20" min="5" max="100"></label>
    </fieldset>
  `;

        // Hook inputs to tool options
        const propFont = document.getElementById("propFont");
        if (propFont)
          propFont.onchange = (e) =>
            (document.getElementById("fontFamily").value = e.target.value);

        const propTextSize = document.getElementById("propTextSize");
        if (propTextSize)
          propTextSize.oninput = (e) =>
            (document.getElementById("fontSize").value = e.target.value);

        const propTextColor = document.getElementById("propTextColor");
        if (propTextColor)
          propTextColor.oninput = (e) =>
            (document.getElementById("fontColor").value = e.target.value);

        const propPenColor = document.getElementById("propPenColor");
        if (propPenColor)
          propPenColor.oninput = (e) =>
            (document.getElementById("penColor").value = e.target.value);

        const propPenSize = document.getElementById("propPenSize");
        if (propPenSize)
          propPenSize.oninput = (e) =>
            (document.getElementById("penSize").value = e.target.value);

        const propHighlightColor =
          document.getElementById("propHighlightColor");
        if (propHighlightColor)
          propHighlightColor.oninput = (e) =>
            (document.getElementById("penColor").value = e.target.value);

        const propHighlightSize = document.getElementById("propHighlightSize");
        if (propHighlightSize)
          propHighlightSize.oninput = (e) =>
            (document.getElementById("penSize").value = e.target.value);

        const propShapeType = document.getElementById("propShapeType");
        if (propShapeType)
          propShapeType.onchange = (e) =>
            (document.getElementById("shapeType").value = e.target.value);

        const propShapeColor = document.getElementById("propShapeColor");
        if (propShapeColor)
          propShapeColor.oninput = (e) =>
            (document.getElementById("shapeColor").value = e.target.value);

        const propShapeSize = document.getElementById("propShapeSize");
        if (propShapeSize)
          propShapeSize.oninput = (e) =>
            (document.getElementById("shapeSize").value = e.target.value);

        const propShapeFill = document.getElementById("propShapeFill");
        if (propShapeFill)
          propShapeFill.oninput = (e) =>
            (document.getElementById("shapeFill").value = e.target.value);
      }

      // Always show properties for tools
      updatePropertiesPanel();

      function setObjectX(o, x) {
        if (o.x !== undefined) o.x = x;
        if (o.x1 !== undefined) o.x1 += x - (o.x1 || 0);
        if (o.x2 !== undefined) o.x2 += x - (o.x2 || 0);
      }
      function setObjectY(o, y) {
        if (o.y !== undefined) o.y = y;
        if (o.y1 !== undefined) o.y1 += y - (o.y1 || 0);
        if (o.y2 !== undefined) o.y2 += y - (o.y2 || 0);
      }

      function eraseAtPoint(pos, pageIndex) {
        const hitObj = objects.find(
          (o) => o.page === pageIndex && isPointInsideObject(pos, o)
        );
        if (hitObj) {
          objects = objects.filter((o) => o.id !== hitObj.id);
          drawObjects();
          saveState();
        }
      }

      // ===================== EXPORT PDF =====================
      document.getElementById("exportPDF").onclick = async () => {
        if (!pages || pages.length === 0) {
          alert("No PDF loaded");
          return;
        }

        try {
          const { PDFDocument } = PDFLib;
          const newPdf = await PDFDocument.create();
          const DPI = 300; // Ultra-high DPI (300 DPI = print quality)
          const PX_TO_POINTS = 72 / DPI; // Convert pixels to PDF points

          for (let i = 0; i < pages.length; i++) {
            const pdfCanvas = pages[i].pdfCanvas;
            const drawCanvas = pages[i].drawCanvas;

            if (pdfCanvas.width > 0 && pdfCanvas.height > 0) {
              // Use rendered size - maintains what you see on screen
              const pageWidth = pdfCanvas.width * PX_TO_POINTS;
              const pageHeight = pdfCanvas.height * PX_TO_POINTS;

              const newPage = newPdf.addPage([pageWidth, pageHeight]);

              // Create combined canvas with both PDF and drawings
              // Use 2x scaling for crisp rendering
              const scale = 2;
              const combinedCanvas = document.createElement("canvas");
              combinedCanvas.width = pdfCanvas.width * scale;
              combinedCanvas.height = pdfCanvas.height * scale;
              const ctx = combinedCanvas.getContext("2d");
              ctx.scale(scale, scale);

              // Draw PDF page
              ctx.drawImage(pdfCanvas, 0, 0);

              // Draw annotations on top
              ctx.drawImage(drawCanvas, 0, 0);

              const imgData = combinedCanvas.toDataURL("image/png");
              const pngImage = await newPdf.embedPng(imgData);
              newPage.drawImage(pngImage, {
                x: 0,
                y: 0,
                width: pageWidth,
                height: pageHeight,
              });
            }
          }

          const pdfBytesExport = await newPdf.save();
          const blob = new Blob([pdfBytesExport], { type: "application/pdf" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "edited.pdf";
          a.click();
          URL.revokeObjectURL(url);
          alert("PDF exported successfully!");
        } catch (e) {
          console.error("Export error:", e);
          alert("Error exporting PDF: " + e.message);
        }
      };
    </script>
  </body>
</html>
